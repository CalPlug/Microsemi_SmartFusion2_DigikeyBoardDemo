/*******************************************************************************
 *Microsemi Robotic Arm Demo for Sample Sorting for SmartFusion2
 *Application code (c) Copyright 2017 Microsemi SoC Products Group & Calit2 at the University of California, Irvine.
 *Base Example code (c) Copyright 2015 Microsemi SoC Products Group.  All rights reserved.
 *Extended application by Tim McCarthy (Microsemi) and Michael Klopfer (Calit2) + Calit2 student team
 *This example project demonstrates control  control the duty cycle of
 *individual PWM outputs to drive servos for a mechanical arm that sorts test tubes in a rack.  The application is driven by serial commands.
 *Final Build v1.0: April 2017
 *
 */

#include "platform.h"
#include "drivers/CorePWM/core_pwm.h"
#include "drivers/mss_timer/mss_timer.h"
#include "CMSIS/system_m2sxxx.h"
#include "hal.h"
#include "drivers/CoreUARTapb/core_uart_apb.h"
#include "drivers/CoreGPIO/core_gpio.h"
#include "m2sxxx.h"
#include <stdio.h>  //used for ARM Semihosting (Console Debug)

//**************************************************************************************************
//Debugging Control     NOTE: Comment out on production eNVM builds to avoid Semihosting errors!!  (There is no target for the debug messages when running without a console)
//#define VERBOSEDEBUGCONSOLE //Verbose debugging in console using ARM Semihosting, comment out to disable console debug messages - do not go too crazy with Semihosting, it will slow down operation if used excessively.
//**************************************************************************************************

#ifdef VERBOSEDEBUGCONSOLE
	   extern void initialise_monitor_handles(void); //ARM Semihosting enabled
#endif


/******************************************************************************
 * Sample baud value to achieve UART communication at a 115200 baud rate with a (50MHz Digikeyboard clock source.
 * This value is calculated using the following equation:
 *      BAUD_VALUE = (CLOCK / (16 * BAUD_RATE)) - 1
 *      For CoreUART
 *****************************************************************************/
#define BAUD_VALUE    26	   // 26 as calculated baud value for 115200, used for Sparkfun BluetoothMate Gold default baud


/******************************************************************************
 * Maximum UART receiver buffer size.
 *****************************************************************************/
#define MAX_RX_DATA_SIZE    32 //this value can be larger, but 32 is chosen as opposed to the default 256 as only single characters needed in the scheme used.


/******************************************************************************
 * CoreGPIO instance data.
 *****************************************************************************/
gpio_instance_t g_gpio;


/******************************************************************************
 * CoreUARTapb instance data.
 *****************************************************************************/
UART_instance_t g_uart;
uint32_t duty_cycle = 1;  //Set PWM initial duty cycle
#define COREUARTAPB0_BASE_ADDR	0x50002000

/******************************************************************************
 * TX Send message (heartbeat)
 *****************************************************************************/
uint8_t g_message[] ="Hello World";  //Heartbeat message - send back heartbeat command to tablet link, this is the UART message to reply with, and is used by tablet to assess connection is still active  (Note: alternatively "K\n\r" can be used with corresponding parsing on the receive side);

/******************************************************************************
 * Indicator LEDS driven by GPIO Outs
 *****************************************************************************/
/*
 * LEDs masks used to switch on/off LED through GPIOs.
 */
#define LEDS_MASK   (uint32_t)0x00000002		// Defined default LED mask - changed because only GPIO[2:0]are used  (#define LEDS_MASK   (uint32_t)0xAAAAAAAA      // original implementation)

/*
 * LEDs pattern
 */
volatile uint32_t g_gpio_pattern = LEDS_MASK;

/******************************************************************************
 * CorePWM declare base_addr.
 *****************************************************************************/
#define COREPWM_BASE_ADDR 0x50000000
/******************************************************************************
 * CorePWM instance data.
 *****************************************************************************/
pwm_instance_t the_pwm;


/******************************************************************************
/******************************************************************************

/******************************************************************************
 * Servo Control constants
 *****************************************************************************/


/******************************************************************************
 * Delay count used to time the delay between duty cycle updates.  (Unless fabric is changed please do not modify, unless you have an exceedingly good reason to do so)
 *****************************************************************************/
#define DELAY_COUNT     6500  //principle multiplier to set delays in function (changing this changes the length of all delays, modify with caution, should be set so a delay of 1000 = 1 second, hence a unit is equalled approximately to 1 ms)

/******************************************************************************
 * PWM prescale and period configuration values to set PWM frequency and duty cycle.  (Unless fabric is changed please do not modify, unless you have an exceedingly good reason to do so, these values work for hobby servos)
 *****************************************************************************/
#define PWM_PRESCALE    4  //Prescale value 4 (formerly set to 39)
#define PWM_PERIOD      3999  //full period     (formerly set to 499)
//4 & 399 equate to 5us/step - practically this is 400 steps for 180 degrees of roation resolution, not bad!


/******************************************************************************
//Servo Name mapping to PWM Outputs
 ******************************************************************************/
#define LED1 1 //(Digi-Key Board- Pin 117)
#define LED2 2 //(Digi-Key Board- Pin 118)
#define LED3 3 //(Digi-Key Board- Pin 122)
#define LED4 4 //(Digi-Key Board- Pin 123)
#define LED5 5 //(Digi-Key Board- Pin 124)
#define LED6 6 //(Digi-Key Board- Pin 125)
#define LED7 7 //(Digi-Key Board- Pin 128)
#define LED8 8 //(Digi-Key Board- Pin 129)



//***********************************************************************
//***********************************************************************

/******************************************************************************
 * Local function prototypes.
 *****************************************************************************/
void delay( int mult );


/******************************************************************************
 * Program MAIN function.
 *****************************************************************************/
int main( void )
{
	int duty_cycle = 1; // Set PWM initial duty cycle
	#ifdef VERBOSEDEBUGCONSOLE
	    initialise_monitor_handles();  //Add in semihosting
		iprintf("Debug messages via ARM Semihosting initialized\n");  //Notification of Semihosting enabled
	#endif
	    /**************************************************************************
	     * Initialize the CorePWM instance setting the prescale and period values.
	     *************************************************************************/
	    PWM_init( &the_pwm, COREPWM_BASE_ADDR, PWM_PRESCALE, PWM_PERIOD );
//	    delay(200);  //add ~200ms delay to prevent HAL assertion issue
	    /**************************************************************************
	     * Set the initial duty cycle for CorePWM output 1.
	     *************************************************************************/



	    #ifdef VERBOSEDEBUGCONSOLE
	        iprintf("Complete PWM Initialization and initial position start\n");
	    #endif
//	    	delay (500); //Pause at HOLD position then continue operation


/**************************************************************************
* Initialize communication components of application
*************************************************************************/

		//Initialize UART RX buffer
		uint8_t rx_data[MAX_RX_DATA_SIZE]={0}; //initialize buffer as all 0's
	    size_t rx_size;

	    /**************************************************************************
	     * Initialize CoreUARTapb with its base address, baud value, and line
	     * configuration.
	     *************************************************************************/
	    UART_init( &g_uart, COREUARTAPB0_BASE_ADDR,
	    BAUD_VALUE, (DATA_8_BITS | NO_PARITY) ); //set to communicate with 115200/8/N/1
		#ifdef VERBOSEDEBUGCONSOLE
		iprintf("CoreUARTapb initialized\n");
		#endif


		/**************************************************************************
	     * Send initial heartbeat signal
	     *************************************************************************/
	    UART_send( &g_uart, g_message, sizeof(g_message) ); //prepare UART for message sending, send first heartbeat
		#ifdef VERBOSEDEBUGCONSOLE
				iprintf("first heartbeat\n");
		#endif
		/*--------------------------------------------------------------------------
		* Ensure the CMSIS-PAL provided g_FrequencyPCLK0 global variable contains
		* the correct frequency of the APB bus connecting the MSS timer to the
		* rest of the system.
		*/
		SystemCoreClockUpdate();

/**************************************************************************
* Initialize the CoreGPIO driver with the base address of the CoreGPIO
* instance to use and the initial state of the outputs.
*************************************************************************/
    GPIO_init( &g_gpio,    COREGPIO_BASE_ADDR, GPIO_APB_32_BITS_BUS );

/**************************************************************************
* Configure the GPIOs for the indicator LEDs
*************************************************************************/
    GPIO_config( &g_gpio, GPIO_0, GPIO_OUTPUT_MODE );  //BUTTON1 (Physically the red element of the LED 1 bi-color LED on the Future Creative board) - the green element of this bi-color LED is the PWM demo output
    GPIO_config( &g_gpio, GPIO_1, GPIO_OUTPUT_MODE );  //BUTTON2 (Physically the green element of the LED 2 bi-color LED on the Future Creative board)
    GPIO_config( &g_gpio, GPIO_2, GPIO_OUTPUT_MODE );  //Led #3 (Physically the red element of the LED 2 bi-color LED on the Future Creative board)
    GPIO_set_outputs(&g_gpio, g_gpio_pattern); //Write default pattern to LEDs

    /**************************************************************************
     * Configure the GPIOs for Inputs.
     *************************************************************************/
    GPIO_config( &g_gpio, GPIO_0, GPIO_INOUT_MODE | GPIO_IRQ_EDGE_POSITIVE  );  //Button 1
    GPIO_config( &g_gpio, GPIO_1, GPIO_INOUT_MODE | GPIO_IRQ_EDGE_POSITIVE  ); //Button 2
    GPIO_config( &g_gpio, GPIO_2, GPIO_OUTPUT_MODE ); //Spare input button, currently disabled

#ifdef VERBOSEDEBUGCONSOLE
    iprintf("CoreGPIO configured\n");
#endif
    /*
     * Enable individual GPIO interrupts. The interrupts must be enabled both at
     * the GPIO peripheral and Cortex-M3 interrupt controller levels.
     */
    GPIO_enable_irq( &g_gpio, GPIO_0 ); //enable IRQ for button 1
    GPIO_enable_irq( &g_gpio, GPIO_1 ); //enable IRQ for button 2
    /*
     * The following section was modified by TM on 4/18/17
     */
      NVIC_EnableIRQ(FabricIrq1_IRQn);
      NVIC_EnableIRQ(FabricIrq2_IRQn);

      // FabricIrq1 is from GPIN[0] which is connected to SW1; FabricIrq2 is from GPIN[1] which is connected to SW2
	  NVIC_SetPriority(FabricIrq1_IRQn, 6u);
	  NVIC_SetPriority(FabricIrq2_IRQn, 5u);	// set IRQ2 to a higher level than IRQ1; If SW2 is pressed while SW1 is depresses SW2 IRQ2 ISR will be executed

    /**************************************************************************
     * Configure Timer1
     * Use the timer input frequency as load value to achieve a one second
     * periodic interrupt.
    /*************************************************************************/
	uint32_t timer1_load_value;
    timer1_load_value = g_FrequencyPCLK0 *5;		// modify for 10 second delay TM
    MSS_TIM1_init(MSS_TIMER_PERIODIC_MODE);
    MSS_TIM1_load_immediate(timer1_load_value);
    MSS_TIM1_start();
    MSS_TIM1_enable_irq();

    #ifdef VERBOSEDEBUGCONSOLE
	iprintf("Timer initialized and started\n");
    #endif


    /*--------------------------------------------------------------------------
     * Foreground loop to check for command control of the device.
     */

for(;;)
    {
	//	GPIO_set_outputs(&g_gpio, g_gpio_pattern); //update GPIO pattern for indicator LEDs (default pattern)
    	if(UART_APB_NO_ERROR == UART_get_rx_status(&g_uart)) //Verify if UART can be opened, then open UART to receive control command
		        {
		            /**********************************************************************
		             * Read data received by the UART.
		             *********************************************************************/
		            rx_size = UART_get_rx( &g_uart, rx_data, sizeof(rx_data) ); //Read UART buffer and get size
		        }
    //This group of IF statements checks for incoming commands and initiates motions if they are received, single ASCII characters are used to trigger subroutines for motion.
		        	if ( rx_size > 0 && rx_data[0]=='A' )
		             	{
						#ifdef VERBOSEDEBUGCONSOLE
		             	iprintf("Routine 'A' Received - LED1\n"); //Identify operation via semihosting debug print
						#endif
		             	rx_data[0]=0; //flush first position in the buffer before next check with null character
		             	PWM_set_duty_cycle(&the_pwm, PWM_1, 1); //turn on LED1
		             	PWM_set_duty_cycle(&the_pwm, PWM_1, 0); //turn off
		             	}
		             else if ( rx_size > 0 && rx_data[0]=='B' )
		             	{
						#ifdef VERBOSEDEBUGCONSOLE
		                iprintf("Routine 'B' Received -LED2\n"); //Identify operation via semihosting debug print
						#endif
		                rx_data[0]=0; //flush first position in the buffer before next check with null character
		                PWM_set_duty_cycle(&the_pwm, PWM_2, 1); //turn on LED1
		             	PWM_set_duty_cycle(&the_pwm, PWM_2, 0); //turn off
		             	}
		             else if ( rx_size > 0 && rx_data[0]=='C' )
		             	{
						#ifdef VERBOSEDEBUGCONSOLE
		                iprintf("Routine 'C' Received - LED3\n"); //Identify operation via semihosting debug print
						#endif
		                rx_data[0]=0; //flush first position in the buffer before next check with null character
		                PWM_set_duty_cycle(&the_pwm, PWM_3, 1); //turn on LED1
		             	PWM_set_duty_cycle(&the_pwm, PWM_3, 0); //turn off
		             	}
		             else if ( rx_size > 0 && rx_data[0]=='D' )
		                {
						 #ifdef VERBOSEDEBUGCONSOLE
		                 iprintf("Routine 'D' Received - LED4\n"); //Identify operation via semihosting debug print
						 #endif
		                 rx_data[0]=0; //flush first position in the buffer before next check with null character
		                 PWM_set_duty_cycle(&the_pwm, PWM_4, 1); //turn on LED1
		             	 PWM_set_duty_cycle(&the_pwm, PWM_4, 0); //turn off
		                }
		             //Continue checks for the other characters - this code goes here
		             else if ( rx_size > 0 && rx_data[0]=='E' )
		                {
						 #ifdef VERBOSEDEBUGCONSOLE
		            	 iprintf("Routine 'E' Received - Agitate A Operation initiated\n"); //Identify operation via semihosting debug print
						 #endif
		            	 rx_data[0]=0; //flush first position in the buffer before next check with null character
						PWM_set_duty_cycle(&the_pwm, PWM_5, 1); //turn on LED1
		             	PWM_set_duty_cycle(&the_pwm, PWM_5, 0); //turn off
		                }
		             //Continue checks for the other characters - this code goes here
		             else if ( rx_size > 0 && rx_data[0]=='G' )
		                {
						 #ifdef VERBOSEDEBUGCONSOLE
		                 iprintf("Routine 'G' Received - Agitate C Operation initiated\n"); //Identify operation via semihosting debug print
                         #endif
		                 rx_data[0]=0; //flush first position in the buffer before next check with null character
		                PWM_set_duty_cycle(&the_pwm, PWM_6, 1); //turn on LED1
		             	PWM_set_duty_cycle(&the_pwm, PWM_6, 0); //turn off
		                }
		             else if ( rx_size > 0 && rx_data[0]=='I' )
		                {
                         #ifdef VERBOSEDEBUGCONSOLE
		                 iprintf("Routine 'I' Received - Demo Motions Operation initiated\n"); //Identify operation via semihosting debug print
                         #endif
		                 rx_data[0]=0; //flush first position in the buffer before next check with null character
						PWM_set_duty_cycle(&the_pwm, PWM_7, 1); //turn on LED1
		             	PWM_set_duty_cycle(&the_pwm, PWM_7, 0); //turn off
		                }
		             else if ( rx_size > 0 && rx_data[0]== 'J' )
		                {
		                 #ifdef VERBOSEDEBUGCONSOLE
		             	 iprintf("Routine 'J' Received - Calibrations Motions Operation initiated\n"); //Identify operation via semihosting debug print
		                 #endif
		                 rx_data[0]=0; //flush first position in the buffer before next check with null character
		                PWM_set_duty_cycle(&the_pwm, PWM_8, 1); //turn on LED1
		             	PWM_set_duty_cycle(&the_pwm, PWM_8, 0); //turn off
		                }
    	           //Just a helpful tip!  Move function calls for motion into here to test.  They will be executed every time loop runs, remove before testing communication and real functionality of the program.

    	else {}  //Null Case (rounding out the IF statement)

//     }
}


/*==============================================================================
 * Toggle LEDs and send message via UART on TIM1 interrupt.
 */
void Timer1_IRQHandler(void)
{
    /*
     * Toggle GPIO output pattern by doing an exclusive OR of all
     * pattern bits with ones.
    //  */
    // g_gpio_pattern = GPIO_get_outputs( &g_gpio ); //lookup current state of LEDs
    // g_gpio_pattern ^= 0x00000007; //Inversion of previous state
    // GPIO_set_outputs( &g_gpio, g_gpio_pattern);//Update LEDs to inversion of previous state

     UART_send( &g_uart, g_message, sizeof(g_message) ); //send the hearbeat message to let the tablet know the link is still active
	#ifdef VERBOSEDEBUGCONSOLE
     iprintf("Hello World!\n");
	#endif
    /* Clear TIM1 interrupt */
    MSS_TIM1_clear_irq();
}


/**********************************************************************
* Interrupt driven control of function execution.
*********************************************************************/
//Buttons are handled through interrupts.  GPIO 0 interrupt service routine is FabricIrq1 ISR.  GPIO 0: This interrupt service routine function will be called when the SW1.  It will keep getting called as long as the SW1 button is pressed because the GPIO 0 input is configured as a level interrupt source.

 //Example:
    					//Enable Interrupt for Button 1 - GPIO_disable_irq( &g_gpio, GPIO_0 ); is changed to GPIO_enable_irq( &g_gpio, GPIO_0 );
        				//Enable Interrupt for Button 2 - GPIO_disable_irq( &g_gpio, GPIO_1 ); is changed to GPIO_enable_irq( &g_gpio, GPIO_1 );
    	    				  //If button 1 Press (manual demo activation), run the function "Demo();"
    	           	   	   	  //If button 2 press, (ESTOP) - hold and catch fire (HCF), disable all PWMS and put program into infinite null loop that is reset only by resetting the board.

void FabricIrq1_IRQHandler( void )
{
    /*
      * Disable GPIO interrupts while updating the delay counter and
      * GPIO pattern since these can also be modified within the GPIO
      * interrupt service routines.
      */
	GPIO_disable_irq( &g_gpio, GPIO_0 );
    GPIO_disable_irq( &g_gpio, GPIO_1 );

    /******************************************************************************
     * Write a message to the SoftConsole host via OpenOCD and the debugger
     *****************************************************************************/
	#ifdef VERBOSEDEBUGCONSOLE
		initialise_monitor_handles();
		iprintf("Switch 1 pressed - Manual Demo Trigger\n");
	#endif
		// GPIO_set_outputs(&g_gpio, 0x00000004);  //Change LEDS to indicate this is run

    	    GPIO_clear_irq( &g_gpio, GPIO_0 );  //clear IRQ - Button 1
    	    GPIO_clear_irq( &g_gpio, GPIO_1 ); //clear IRQ - Button 2
    	    GPIO_enable_irq( &g_gpio, GPIO_0 );//Enable interrupt to button 1 (//GPIO_disable_irq( &g_gpio, GPIO_0 );)
    	    GPIO_enable_irq( &g_gpio, GPIO_1 );//Enable interrupt to button 2 (//GPIO_disable_irq( &g_gpio, GPIO_0 );)
    	    while (1==1) //infinite loop for demo - only stopped by resetting
    	    {
				#ifdef VERBOSEDEBUGCONSOLE
    	    	iprintf("Execution of ""Demo Motion"" routine - Push and hold ""Stop & Lock"" button to stop demo\n"); //this is an E-STOP
				#endif

    	    	delay (4000); //delay before repeating function
    	    }

    /*
     * Clear interrupt both at the GPIO levels.
     */
    GPIO_clear_irq( &g_gpio, GPIO_0 );
    GPIO_clear_irq( &g_gpio, GPIO_1 );

    /*
     * Clear the interrupt in the Cortex-M3 NVIC.
     */
    NVIC_ClearPendingIRQ(FabricIrq1_IRQn);
    GPIO_enable_irq( &g_gpio, GPIO_0 ); //re-enable IRQ for Button 1
    GPIO_enable_irq( &g_gpio, GPIO_1 );  //re-enable IRQ for Button 2

    #ifdef VERBOSEDEBUGCONSOLE
    iprintf("Interrupt Action Routine Complete - Returning to Main Function\n"); //Just a notation that the interrupt routine has finished
	#endif
}



//GPIO 1 interrupt service routine is FabricIrq2 ISR.
//GPIO 1 : This interrupt service routine function will be called when the SW2 button is pressed. It will only be called once even if the SW2 button is kept pressed because the GPIO 1 input is configured as a rising edge interrupt source. This ISR loops forever after the SW2 button is pressed.  The debugger must be terminated and re-launched or the board reset (if running without the debugger) to run the application again.

void FabricIrq2_IRQHandler( void )
{
    /*
      * If SW2 (stop switch) is pressed, disable PWM outputs and halt until board is reset or debugger is re-launched, this is an effective E-STOP
      */
	MSS_TIM1_disable_irq();					// disable the MSS timer interrupt
	GPIO_disable_irq( &g_gpio, GPIO_0 );	// disable the GPIO_0 (SW1) interrupt
    //GPIO_disable_irq( &g_gpio, GPIO_1 );	// keep the GPIO_1 (SW2) interrupt enabled

    /******************************************************************************
     * Write a message to the SoftConsole host via OpenOCD and the debugger
     *****************************************************************************/
	#ifdef VERBOSEDEBUGCONSOLE
		initialise_monitor_handles();
		iprintf("Switch 2 pressed - FabricIRq2; Restart the debugger to run the application\n");  //Print message that SW2 was pressed
	#endif

		// GPIO_set_outputs(&g_gpio, 0x00000005);  //Turn both LEDs RED to indicate ESTOP condition

	//Disabl`	e PWM Outputs to halt Servo
		PWM_disable (&the_pwm, PWM_1);
		PWM_disable (&the_pwm, PWM_2);
		PWM_disable (&the_pwm, PWM_3);
		PWM_disable (&the_pwm, PWM_4);
		PWM_disable (&the_pwm, PWM_5);
		PWM_disable (&the_pwm, PWM_6);
		PWM_disable (&the_pwm, PWM_7);
		PWM_disable (&the_pwm, PWM_8);

	#ifdef VERBOSEDEBUGCONSOLE
		initialise_monitor_handles();
		iprintf("PWM outputs disabled\n");  //Print message that PWM outputs were disabled
	#endif

		for (;;)
		{
		//lock in infinite loop until board is reset - where the ESTOP ends
		}

}

/******************************************************************************
 * Delay function.
 *****************************************************************************/
void delay( int mult )
{
    volatile int counter = 0;

    while ( counter < (DELAY_COUNT*mult) )
    {
        counter++;
    }
}
}



